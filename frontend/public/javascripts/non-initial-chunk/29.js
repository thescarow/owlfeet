"use strict";(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[29],{29:(e,t,s)=>{s.r(t),s.d(t,{default:()=>x});var r=s(3521),i=s(2740),o=s(3357),a=s(4821),n=s(4359),l=s(7570),u=s(7925),p=s(2943);let d;function h(e,t){if(!Object.prototype.hasOwnProperty.call(e,t))throw new TypeError("attempted to use private field on non-instance");return e}var c=0;function m(e){return"__private_"+c+++"_"+e}function y(e){if(e&&e.error){const t=new Error(e.message);throw Object.assign(t,e.error),t}return e}function v(e){if(null!=e&&e.aborted)throw(0,u.zE)("The operation was aborted",{cause:e.reason})}var b=m("abortMultipartUpload"),w=m("cache"),f=m("createMultipartUpload"),g=m("fetchSignature"),P=m("listParts"),U=m("previousRetryDelay"),k=m("requests"),E=m("retryDelayIterator"),R=m("sendCompletionRequest"),O=m("setS3MultipartState"),S=m("uploadPartBytes"),C=m("shouldRetry");class M{constructor(e,t,s){Object.defineProperty(this,C,{value:F}),Object.defineProperty(this,b,{writable:!0,value:void 0}),Object.defineProperty(this,w,{writable:!0,value:new WeakMap}),Object.defineProperty(this,f,{writable:!0,value:void 0}),Object.defineProperty(this,g,{writable:!0,value:void 0}),Object.defineProperty(this,P,{writable:!0,value:void 0}),Object.defineProperty(this,U,{writable:!0,value:void 0}),Object.defineProperty(this,k,{writable:!0,value:void 0}),Object.defineProperty(this,E,{writable:!0,value:void 0}),Object.defineProperty(this,R,{writable:!0,value:void 0}),Object.defineProperty(this,O,{writable:!0,value:void 0}),Object.defineProperty(this,S,{writable:!0,value:void 0}),h(this,k)[k]=e,h(this,O)[O]=s,this.setOptions(t)}setOptions(e){const t=h(this,k)[k];var s;"abortMultipartUpload"in e&&(h(this,b)[b]=t.wrapPromiseFunction(e.abortMultipartUpload)),"createMultipartUpload"in e&&(h(this,f)[f]=t.wrapPromiseFunction(e.createMultipartUpload,{priority:-1})),"signPart"in e&&(h(this,g)[g]=t.wrapPromiseFunction(e.signPart)),"listParts"in e&&(h(this,P)[P]=t.wrapPromiseFunction(e.listParts)),"completeMultipartUpload"in e&&(h(this,R)[R]=t.wrapPromiseFunction(e.completeMultipartUpload)),"retryDelays"in e&&(h(this,E)[E]=null==(s=e.retryDelays)?void 0:s.values()),"uploadPartBytes"in e&&(h(this,S)[S]=t.wrapPromiseFunction(e.uploadPartBytes,{priority:1/0}))}async getUploadId(e,t){const s=h(this,w)[w].get(e.data);if(null!=s)return s;const r=h(this,f)[f](e,t),i=()=>{r.abort(t.reason),h(this,w)[w].delete(e.data)};return t.addEventListener("abort",i,{once:!0}),h(this,w)[w].set(e.data,r),r.then((async s=>{t.removeEventListener("abort",i),h(this,O)[O](e,s),h(this,w)[w].set(e.data,s)}),(()=>{t.removeEventListener("abort",i)})),r}async abortFileUpload(e){const t=h(this,w)[w].get(e.data);null!=t&&await h(this,b)[b](e,await t)}async uploadFile(e,t,s){v(s);const{uploadId:r,key:i}=await this.getUploadId(e,s);v(s);const o=await Promise.all(t.map(((t,r)=>this.uploadChunk(e,r+1,t,s))));return v(s),h(this,R)[R](e,{key:i,uploadId:r,parts:o,signal:s}).abortOn(s)}async resumeUploadFile(e,t,s){v(s);const{uploadId:r,key:i}=await this.getUploadId(e,s);v(s);const o=await h(this,P)[P](e,{uploadId:r,key:i,signal:s}).abortOn(s);v(s);const a=await Promise.all(t.map(((t,r)=>{const i=r+1,a=o.find((e=>{let{PartNumber:t}=e;return t===i}));return null==a?this.uploadChunk(e,i,t,s):{PartNumber:i,ETag:a.ETag}})));return v(s),h(this,R)[R](e,{key:i,uploadId:r,parts:a,signal:s}).abortOn(s)}async uploadChunk(e,t,s,r){v(r);const{uploadId:i,key:o}=await this.getUploadId(e,r);for(v(r);;){const a=await h(this,g)[g](e,{uploadId:i,key:o,partNumber:t,body:s,signal:r}).abortOn(r);v(r);try{return{PartNumber:t,...await h(this,S)[S](a,s,r).abortOn(r)}}catch(e){if(!await h(this,C)[C](e))throw e}}}}async function F(e){var t;const s=h(this,k)[k],r=null==e||null==(t=e.source)?void 0:t.status;if(null==r)return!1;if(403===r&&"Request has expired"===e.message){if(!s.isPaused){if(1===s.limit||null==h(this,U)[U]){var i;const e=null==(i=h(this,E)[E])?void 0:i.next();if(null==e||e.done)return!1;h(this,U)[U]=e.value}s.rateLimit(0),await new Promise((e=>setTimeout(e,h(this,U)[U])))}}else if(429===r){if(!s.isPaused){var o;const e=null==(o=h(this,E)[E])?void 0:o.next();if(null==e||e.done)return!1;s.rateLimit(e.value)}}else{if(r>400&&r<500&&409!==r)return!1;if("undefined"!=typeof navigator&&!1===navigator.onLine)s.isPaused||(s.pause(),window.addEventListener("online",(()=>{s.resume()}),{once:!0}));else{var a;const e=null==(a=h(this,E)[E])?void 0:a.next();if(null==e||e.done)return!1;await new Promise((t=>setTimeout(t,e.value)))}}return!0}var I=m("queueRequestSocketToken"),j=m("companionCommunicationQueue"),T=m("client"),L=m("setS3MultipartState"),$=m("requestSocketToken"),q=m("setCompanionHeaders");d=Symbol.for("uppy test: getClient");class x extends r{constructor(e,t){var s;super(e,t),Object.defineProperty(this,I,{writable:!0,value:void 0}),Object.defineProperty(this,j,{writable:!0,value:void 0}),Object.defineProperty(this,T,{writable:!0,value:void 0}),Object.defineProperty(this,L,{writable:!0,value:(e,t)=>{let{key:s,uploadId:r}=t;const i=this.uppy.getFile(e.id);this.uppy.setFileState(e.id,{s3Multipart:{...i.s3Multipart,key:s,uploadId:r}})}}),Object.defineProperty(this,$,{writable:!0,value:async e=>{const t=new(e.remote.providerOptions.provider?i.zt:i.C$)(this.uppy,e.remote.providerOptions),s={...this.opts};if(e.tus&&Object.assign(s,e.tus),null==e.remote.url)throw new Error("Cannot connect to an undefined URL");return(await t.post(e.remote.url,{...e.remote.body,protocol:"s3-multipart",size:e.data.size,metadata:e.meta})).token}}),Object.defineProperty(this,q,{writable:!0,value:()=>{h(this,T)[T].setCompanionHeaders(this.opts.companionHeaders)}}),this.type="uploader",this.id=this.opts.id||"AwsS3Multipart",this.title="AWS S3 Multipart",h(this,T)[T]=new i.C$(e,t);const r={limit:6,retryDelays:[0,1e3,3e3,5e3],createMultipartUpload:this.createMultipartUpload.bind(this),listParts:this.listParts.bind(this),abortMultipartUpload:this.abortMultipartUpload.bind(this),completeMultipartUpload:this.completeMultipartUpload.bind(this),signPart:this.signPart.bind(this),uploadPartBytes:x.uploadPartBytes,companionHeaders:{}};this.opts={...r,...t},null!=(null==t?void 0:t.prepareUploadParts)&&null==t.signPart&&(this.opts.signPart=async(e,s)=>{let{uploadId:r,key:i,partNumber:o,body:a,signal:n}=s;const{presignedUrls:l,headers:u}=await t.prepareUploadParts(e,{uploadId:r,key:i,parts:[{number:o,chunk:a}],signal:n});return{url:null==l?void 0:l[o],headers:null==u?void 0:u[o]}}),this.upload=this.upload.bind(this),this.requests=null!=(s=this.opts.rateLimitedQueue)?s:new l.s(this.opts.limit),h(this,j)[j]=new M(this.requests,this.opts,h(this,L)[L]),this.uploaders=Object.create(null),this.uploaderEvents=Object.create(null),this.uploaderSockets=Object.create(null),h(this,I)[I]=this.requests.wrapPromiseFunction(h(this,$)[$],{priority:-1})}[d](){return h(this,T)[T]}setOptions(e){return h(this,j)[j].setOptions(e),super.setOptions(e)}resetUploaderReferences(e,t){void 0===t&&(t={}),this.uploaders[e]&&(this.uploaders[e].abort({really:t.abort||!1}),this.uploaders[e]=null),this.uploaderEvents[e]&&(this.uploaderEvents[e].remove(),this.uploaderEvents[e]=null),this.uploaderSockets[e]&&(this.uploaderSockets[e].close(),this.uploaderSockets[e]=null)}assertHost(e){if(!this.opts.companionUrl)throw new Error(`Expected a \`companionUrl\` option containing a Companion address, or if you are not using Companion, a custom \`${e}\` implementation.`)}createMultipartUpload(e,t){this.assertHost("createMultipartUpload"),v(t);const s={};return Object.keys(e.meta||{}).forEach((t=>{null!=e.meta[t]&&(s[t]=e.meta[t].toString())})),h(this,T)[T].post("s3/multipart",{filename:e.name,type:e.type,metadata:s},{signal:t}).then(y)}listParts(e,t,s){let{key:r,uploadId:i}=t;this.assertHost("listParts"),v(s);const o=encodeURIComponent(r);return h(this,T)[T].get(`s3/multipart/${i}?key=${o}`,{signal:s}).then(y)}completeMultipartUpload(e,t,s){let{key:r,uploadId:i,parts:o}=t;this.assertHost("completeMultipartUpload"),v(s);const a=encodeURIComponent(r),n=encodeURIComponent(i);return h(this,T)[T].post(`s3/multipart/${n}/complete?key=${a}`,{parts:o},{signal:s}).then(y)}signPart(e,t){let{uploadId:s,key:r,partNumber:i,signal:o}=t;if(this.assertHost("signPart"),v(o),null==s||null==r||null==i)throw new Error("Cannot sign without a key, an uploadId, and a partNumber");const a=encodeURIComponent(r);return h(this,T)[T].get(`s3/multipart/${s}/${i}?key=${a}`,{signal:o}).then(y)}abortMultipartUpload(e,t,s){let{key:r,uploadId:i}=t;this.assertHost("abortMultipartUpload");const o=encodeURIComponent(r),a=encodeURIComponent(i);return h(this,T)[T].delete(`s3/multipart/${a}?key=${o}`,void 0,{signal:s}).then(y)}static async uploadPartBytes(e,t,s){let{url:r,expires:i,headers:o}=e;if(v(s),null==r)throw new Error("Cannot upload to an undefined URL");return new Promise(((e,a)=>{const n=new XMLHttpRequest;function l(){n.abort()}function p(){s.removeEventListener("abort",l)}n.open("PUT",r,!0),o&&Object.keys(o).forEach((e=>{n.setRequestHeader(e,o[e])})),n.responseType="text","number"==typeof i&&(n.timeout=1e3*i),s.addEventListener("abort",l),n.upload.addEventListener("progress",t.onProgress),n.addEventListener("abort",(()=>{p(),a((0,u.zE)())})),n.addEventListener("timeout",(()=>{p();const e=new Error("Request has expired");e.source={status:403},a(e)})),n.addEventListener("load",(s=>{if(p(),403===s.target.status&&s.target.responseText.includes("<Message>Request has expired</Message>")){const e=new Error("Request has expired");return e.source=s.target,void a(e)}if(s.target.status<200||s.target.status>=300){const e=new Error("Non 2xx");return e.source=s.target,void a(e)}null==t.onProgress||t.onProgress(t.size);const r=s.target.getResponseHeader("ETag");null!==r?(null==t.onComplete||t.onComplete(r),e({ETag:r})):a(new Error("AwsS3/Multipart: Could not read the ETag header. This likely means CORS is not configured correctly on the S3 Bucket. See https://uppy.io/docs/aws-s3-multipart#S3-Bucket-Configuration for instructions."))})),n.addEventListener("error",(e=>{p();const t=new Error("Unknown error");t.source=e.target,a(t)})),n.send(t)}))}uploadFile(e){var t=this;return new Promise(((s,r)=>{const i=new p.Z(e.data,{companionComm:h(this,j)[j],log:function(){return t.uppy.log(...arguments)},getChunkSize:this.opts.getChunkSize?this.opts.getChunkSize.bind(this):null,onProgress:(t,s)=>{this.uppy.emit("upload-progress",e,{uploader:this,bytesUploaded:t,bytesTotal:s})},onError:t=>{this.uppy.log(t),this.uppy.emit("upload-error",e,t),this.resetUploaderReferences(e.id),r(t)},onSuccess:t=>{const r=i,o={body:{...t},uploadURL:t.location};this.resetUploaderReferences(e.id);const a=this.uppy.getFile(e.id);this.uppy.emit("upload-success",a||e,o),t.location&&this.uppy.log(`Download ${e.name} from ${t.location}`),s(r)},onPartComplete:t=>{const s=this.uppy.getFile(e.id);s&&this.uppy.emit("s3-multipart:part-uploaded",s,t)},file:e,...e.s3Multipart});this.uploaders[e.id]=i,this.uploaderEvents[e.id]=new o.Z(this.uppy),this.onFileRemove(e.id,(t=>{i.abort(),this.resetUploaderReferences(e.id,{abort:!0}),s(`upload ${t.id} was removed`)})),this.onCancelAll(e.id,(function(r){let{reason:o}=void 0===r?{}:r;"user"===o&&(i.abort(),t.resetUploaderReferences(e.id,{abort:!0})),s(`upload ${e.id} was canceled`)})),this.onFilePause(e.id,(e=>{e?i.pause():i.start()})),this.onPauseAll(e.id,(()=>{i.pause()})),this.onResumeAll(e.id,(()=>{i.start()})),e.progress.uploadStarted&&e.isRestored||(i.start(),this.uppy.emit("upload-started",e))}))}async uploadRemote(e){this.resetUploaderReferences(e.id),e.progress.uploadStarted&&e.isRestored||this.uppy.emit("upload-started",e);try{if(e.serverToken)return this.connectToServerSocket(e);const t=await h(this,I)[I](e);return this.uppy.setFileState(e.id,{serverToken:t}),this.connectToServerSocket(this.uppy.getFile(e.id))}catch(t){throw this.uppy.emit("upload-error",e,t),t}}async connectToServerSocket(e){var t=this;return new Promise(((s,r)=>{let l;const u=e.serverToken,p=(0,n.Z)(e.remote.companionUrl),d=new i.sk({target:`${p}/api/${u}`});this.uploaderSockets[e.id]=d,this.uploaderEvents[e.id]=new o.Z(this.uppy),this.onFileRemove(e.id,(()=>{l.abort(),d.send("cancel",{}),this.resetUploaderReferences(e.id,{abort:!0}),s(`upload ${e.id} was removed`)})),this.onFilePause(e.id,(e=>{e?(l.abort(),d.send("pause",{})):(l.abort(),l=this.requests.run((()=>(d.send("resume",{}),()=>{}))))})),this.onPauseAll(e.id,(()=>{l.abort(),d.send("pause",{})})),this.onCancelAll(e.id,(function(r){let{reason:i}=void 0===r?{}:r;"user"===i&&(l.abort(),d.send("cancel",{}),t.resetUploaderReferences(e.id)),s(`upload ${e.id} was canceled`)})),this.onResumeAll(e.id,(()=>{l.abort(),e.error&&d.send("pause",{}),l=this.requests.run((()=>{d.send("resume",{})}))})),this.onRetry(e.id,(()=>{d.isOpen&&(d.send("pause",{}),d.send("resume",{}))})),this.onRetryAll(e.id,(()=>{d.isOpen&&(d.send("pause",{}),d.send("resume",{}))})),d.on("progress",(t=>(0,a.Z)(this,t,e))),d.on("error",(t=>{this.uppy.emit("upload-error",e,new Error(t.error)),this.resetUploaderReferences(e.id),l.done(),r(new Error(t.error))})),d.on("success",(t=>{const r={uploadURL:t.url};this.uppy.emit("upload-success",e,r),this.resetUploaderReferences(e.id),l.done(),s()})),l=this.requests.run((()=>(e.isPaused&&d.send("pause",{}),()=>{})))}))}async upload(e){if(0===e.length)return;const t=e.map((e=>{const t=this.uppy.getFile(e);return t.isRemote?this.uploadRemote(t):this.uploadFile(t)}));return Promise.all(t)}onFileRemove(e,t){this.uploaderEvents[e].on("file-removed",(s=>{e===s.id&&t(s.id)}))}onFilePause(e,t){this.uploaderEvents[e].on("upload-pause",((s,r)=>{e===s&&t(r)}))}onRetry(e,t){this.uploaderEvents[e].on("upload-retry",(s=>{e===s&&t()}))}onRetryAll(e,t){this.uploaderEvents[e].on("retry-all",(()=>{this.uppy.getFile(e)&&t()}))}onPauseAll(e,t){this.uploaderEvents[e].on("pause-all",(()=>{this.uppy.getFile(e)&&t()}))}onCancelAll(e,t){var s=this;this.uploaderEvents[e].on("cancel-all",(function(){s.uppy.getFile(e)&&t(...arguments)}))}onResumeAll(e,t){this.uploaderEvents[e].on("resume-all",(()=>{this.uppy.getFile(e)&&t()}))}install(){const{capabilities:e}=this.uppy.getState();this.uppy.setState({capabilities:{...e,resumableUploads:!0}}),this.uppy.addPreProcessor(h(this,q)[q]),this.uppy.addUploader(this.upload)}uninstall(){const{capabilities:e}=this.uppy.getState();this.uppy.setState({capabilities:{...e,resumableUploads:!1}}),this.uppy.removePreProcessor(h(this,q)[q]),this.uppy.removeUploader(this.upload)}}x.VERSION="3.1.1"}}]);